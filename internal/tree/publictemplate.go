package tree

import (
	"fmt"
	"io"
	"strings"
)

const publicPremble = `// Package %s contains the type definitions for %s v%s.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package %s

import (
	"encoding/xml"
	"strings"
	"time"

	schema "github.com/phille97/trafikinfo/internal/trv/%s/%s"
	"github.com/phille97/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func T() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "%s",
		Version:   "%s",
		Namespace: "%s",
	}
}

`

const publicEpilogue = `// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "github.com/phille97/trafikinfo/trv/%s/%s"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name ` + "`xml:\"RESPONSE\"`" + `
	Results []struct {
		Info struct {
			LastModified trv.LastModified ` + "`xml:\"LASTMODIFIED\"`" + `
			LastChangeID string           ` + "`xml:\"LASTCHANGEID\"`" + `
			EvalResult   []any            ` + "`xml:\"EVALRESULT\"`" + `
			SSEURL       string           ` + "`xml:\"SSEURL\"`" + `
		} ` + "`xml:\"INFO\"`" + `
		Error *trv.APIError ` + "`xml:\"ERROR\"`" + `
		Data  []%s      ` + "`xml:\"%s\"`" + `
	} ` + "`xml:\"RESULT\"`" + `
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}

`

const publicStruct = `type %s struct {
	data *schema.%s
}

func (x *%s) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.%s{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

`

func (r *Root) PublicTemplate(w io.Writer) {
	io.WriteString(w, fmt.Sprintf(
		publicPremble,
		r.Meta.PackageVersion(),
		r.Meta.Name,
		r.Meta.Version,
		r.Meta.PackageVersion(),
		strings.ToLower(r.Meta.Name),
		r.Meta.PackageVersion(),
		r.Meta.Name,
		r.Meta.Version,
		r.Meta.Namespace,
	))

	for _, node := range r.Nodes {
		node.PublicRender(w, "")
	}

	typeName := r.Meta.Name
	if r.Meta.Name == "ReasonCode" {
		typeName = "ReasonCodePublic"
	}

	io.WriteString(w, fmt.Sprintf(
		publicEpilogue,
		strings.ToLower(r.Meta.Name),
		r.Meta.PackageVersion(),
		typeName,
		r.Meta.Name,
	))
}

func (n *Node) PublicRender(w io.Writer, name string) {
	if len(n.Documentation) > 0 {
		io.WriteString(w, strings.Join(n.Documentation, "\n"))
		io.WriteString(w, "\n")
	}

	if len(n.Type.Choices) != 0 && name == "" {
		n.PublicRenderEnum(w)
		return
	}

	if name != "" {
		n.PublicRenderMethod(w, name)
		return
	}

	io.WriteString(w, fmt.Sprintf(
		publicStruct,
		n.Name,
		n.Name,
		n.Name,
		n.Name,
	))

	for _, nd := range n.Nodes {
		nd.PublicRender(w, n.Name)
	}
}

func (n *Node) PublicRenderMethod(w io.Writer, name string) {
	io.WriteString(w, "func (x *"+name+") "+goIdentifier(n.Name, n.Multiple)+"() ")
	if n.Multiple {
		io.WriteString(w, "[]")
	} else {
		io.WriteString(w, "*")
	}
	io.WriteString(w, n.Type.Kind+" {\n")
	if n.Type.Final {
		io.WriteString(w, fmt.Sprintf(`if x.data == nil {
return nil
		}
return x.data.%s
`, goName(n.Name)))
	} else {
		if n.Multiple {
			io.WriteString(w, fmt.Sprintf(`if len(x.data.%s) == 0 {
	return nil
	}
	data :=[]%s{}
	for _, mem := range x.data.%s {
		data = append(data, %s{data:&mem})
	}
	return data
`, n.Name, n.Type.Kind, n.Name, n.Type.Kind))
		} else {
			if len(n.Type.Choices) == 0 {
				io.WriteString(w, fmt.Sprintf(
					"if x.data == nil { return &%s{} }\n",
					n.Type.Kind))
				io.WriteString(w, fmt.Sprintf(
					"return &%s{data: x.data.%s}\n",
					n.Type.Kind, n.Name))
			} else {
				io.WriteString(w, "if x.data == nil { return nil }\n")
				io.WriteString(w, fmt.Sprintf("return (*%s)(x.data.%s)\n",
					n.Type.Kind, goIdentifier(n.Name, n.Multiple)))
			}
		}
	}
	io.WriteString(w, "}\n\n")
}

func (n *Node) PublicRenderEnum(w io.Writer) {
	io.WriteString(w, "type "+n.Type.Kind+" "+n.Type.Undertype+"\n\n")
	io.WriteString(w, "const(\n")
	for _, c := range n.Type.Choices {
		io.WriteString(w, n.Type.Kind+goName(c)+" "+n.Type.Kind+" = ")
		if n.Type.Undertype == "string" {
			io.WriteString(w, `"`+c+`"`+"\n")
		} else {
			io.WriteString(w, c+"\n")
		}
	}
	io.WriteString(w, ")\n\n")
}
