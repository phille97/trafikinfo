// Package v1dot2 contains the type definitions for FerryAnnouncement v1.2.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1dot2

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/ferryannouncement/v1dot2"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "FerryAnnouncement",
		Version:   "1.2",
		Namespace: "Ferry.TrafficInfo",
	}
}

type FerryAnnouncement struct {
	data *schema.FerryAnnouncement
}

func (x *FerryAnnouncement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.FerryAnnouncement{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *FerryAnnouncement) Deleted() *bool {
	return x.data.Deleted
}

// SV: Avgångstid
// EN: Departure time
func (x *FerryAnnouncement) DepartureTime() *time.Time {
	return x.data.DepartureTime
}

// SV: Referens till Deviation.Id i objektet Situation
// EN: Reference to Deviation.Id in the Situation object
func (x *FerryAnnouncement) DeviationID() *string {
	return x.data.DeviationId
}

// SV: Avgångens id
// EN: Departure id
func (x *FerryAnnouncement) ID() *int64 {
	return x.data.Id
}

// SV: Information om avgången
// EN: Information about the departure
func (x *FerryAnnouncement) Info() []string {
	return x.data.Info
}

// SV: Avgår från
// EN: Departing from
func (x *FerryAnnouncement) FromHarbor() *FromHarbor {
	return &FromHarbor{data: x.data.FromHarbor}
}

// SV: Ankommer till
// EN: Arriving at
func (x *FerryAnnouncement) ToHarbor() *ToHarbor {
	return &ToHarbor{data: x.data.ToHarbor}
}

// SV: Information om rutten
// EN: Route information
func (x *FerryAnnouncement) Route() *Route {
	return &Route{data: x.data.Route}
}

// EN: Specifies when the object is stored.
// SV: Anger när objektet är sparat.
func (x *FerryAnnouncement) ModifiedTime() *time.Time {
	return x.data.ModifiedTime
}

func (x *FerryAnnouncement) CheckoutID() *string {
	return x.data.Checkoutid
}

func (x *FerryAnnouncement) Checkouts() *int64 {
	return x.data.Checkouts
}

func (x *FerryAnnouncement) LeasedUntil() *time.Time {
	return x.data.Leaseduntil
}

func (x *FerryAnnouncement) Acknowledged() *time.Time {
	return x.data.Acknowledged
}

func (x *FerryAnnouncement) StatusCode() *uint8 {
	return x.data.Statuscode
}

func (x *FerryAnnouncement) ItemsAcknowledged() *int64 {
	return x.data.Itemsacknowledged
}

func (x *FerryAnnouncement) ItemsLeft() *int64 {
	return x.data.Itemsleft
}

type FromHarbor struct {
	data *schema.FromHarbor
}

func (x *FromHarbor) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.FromHarbor{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Avgår från (id)
// EN: Departing from (id)
func (x *FromHarbor) ID() *int {
	return x.data.Id
}

// SV: Avgår från (namn)
// EN: Departing from (name)
func (x *FromHarbor) Name() *string {
	return x.data.Name
}

type ToHarbor struct {
	data *schema.ToHarbor
}

func (x *ToHarbor) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ToHarbor{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Ankommer till (id)
// EN: Arriving at (id)
func (x *ToHarbor) ID() *int {
	return x.data.Id
}

// SV: Ankommer till (namn)
// EN: Arriving at (name)
func (x *ToHarbor) Name() *string {
	return x.data.Name
}

type Route struct {
	data *schema.Route
}

func (x *Route) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Route{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Beskrivande text om rutten
// EN: Descriptive text about the route
func (x *Route) Description() *string {
	return x.data.Description
}

// SV: Ruttens id
// EN: Route id
func (x *Route) ID() *int {
	return x.data.Id
}

// SV: Ruttens namn
// EN: Route name
func (x *Route) Name() *string {
	return x.data.Name
}

// SV: Ruttens kortnamn
// EN: Short name of the route
func (x *Route) Shortname() *string {
	return x.data.Shortname
}

// SV: Ledtyp
// EN: led type
func (x *Route) Type() *Type {
	return &Type{data: x.data.Type}
}

type Type struct {
	data *schema.Type
}

func (x *Type) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Type{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Id för ledtypen
// EN: id for led type
func (x *Type) ID() *int {
	return x.data.Id
}

// SV: Namn för ledtypen (ex. Vändande)
// EN: Name for the led type (ex. Flipping)
func (x *Type) Name() *string {
	return x.data.Name
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/ferryannouncement/v1dot2"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError       `xml:"ERROR"`
		Data  []FerryAnnouncement `xml:"FerryAnnouncement"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
