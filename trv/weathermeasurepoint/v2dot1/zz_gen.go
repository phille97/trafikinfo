// Package v2dot1 contains the type definitions for WeatherMeasurepoint v2.1.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v2dot1

import (
	"encoding/xml"
	"strings"
	"time"

	schema "github.com/phille97/trafikinfo/internal/trv/weathermeasurepoint/v2dot1"
	"github.com/phille97/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func T() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "WeatherMeasurepoint",
		Version:   "2.1",
		Namespace: "",
	}
}

type PrecipTypeMeasure string

const (
	PrecipTypeMeasureNo           PrecipTypeMeasure = "no"
	PrecipTypeMeasureRain         PrecipTypeMeasure = "rain"
	PrecipTypeMeasureFreezingRain PrecipTypeMeasure = "freezing_rain"
	PrecipTypeMeasureSnow         PrecipTypeMeasure = "snow"
	PrecipTypeMeasureSleet        PrecipTypeMeasure = "sleet"
	PrecipTypeMeasureYes          PrecipTypeMeasure = "yes"
)

// SV: Vindsensorns höjdplacering [m]
// EN: Height of the wind sensor [m]
type WindSensorHeight int

const (
	WindSensorHeight6  WindSensorHeight = 6
	WindSensorHeight10 WindSensorHeight = 10
)

type WeatherMeasurepoint struct {
	data *schema.WeatherMeasurepoint
}

func (x *WeatherMeasurepoint) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.WeatherMeasurepoint{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Unik identitet för en mätpunkt
// EN: Unique identity of a measurement point
func (x *WeatherMeasurepoint) ID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Id
}

// SV: Mätpunktens namn
// EN: Name of the measuring point
func (x *WeatherMeasurepoint) Name() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Name
}

func (x *WeatherMeasurepoint) Geometry() *Geometry {
	if x.data == nil {
		return &Geometry{}
	}
	return &Geometry{data: x.data.Geometry}
}

func (x *WeatherMeasurepoint) Observation() *Observation {
	if x.data == nil {
		return &Observation{}
	}
	return &Observation{data: x.data.Observation}
}

// EN: Specifies if the object is deleted.
// SV: Anger om objektet är raderat.
func (x *WeatherMeasurepoint) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

// EN: Specifies when the object is stored.
// SV: Anger när objektet är sparat.
func (x *WeatherMeasurepoint) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

func (x *WeatherMeasurepoint) CheckoutID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Checkoutid
}

func (x *WeatherMeasurepoint) Checkouts() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.Checkouts
}

func (x *WeatherMeasurepoint) LeasedUntil() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.Leaseduntil
}

func (x *WeatherMeasurepoint) Acknowledged() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.Acknowledged
}

func (x *WeatherMeasurepoint) StatusCode() *uint8 {
	if x.data == nil {
		return nil
	}
	return x.data.Statuscode
}

func (x *WeatherMeasurepoint) ItemsAcknowledged() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.Itemsacknowledged
}

func (x *WeatherMeasurepoint) ItemsLeft() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.Itemsleft
}

type Geometry struct {
	data *schema.Geometry
}

func (x *Geometry) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Geometry{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Geometrisk punkt i koordinatsystem SWEREF99TM
// EN: Geometric point in coordinate system SWEREF99TM
func (x *Geometry) SWEREF99TM() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SWEREF99TM
}

// SV: Geometrisk punkt i koordinatsystem WGS84
// EN: Geometric point in coordinate system WGS84
func (x *Geometry) WGS84() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WGS84
}

type Observation struct {
	data *schema.Observation
}

func (x *Observation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Observation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Tidpunkt som observationen avser, inklusive tidzon för att hantera sommartid och normaltid.
// EN: The time to which the observation relates, including the time zone to deal with daylight saving time and standard time.
func (x *Observation) Sample() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.Sample
}

func (x *Observation) Weather() *Weather {
	if x.data == nil {
		return &Weather{}
	}
	return &Weather{data: x.data.Weather}
}

func (x *Observation) Surface() *SurfaceCondition {
	if x.data == nil {
		return &SurfaceCondition{}
	}
	return &SurfaceCondition{data: x.data.Surface}
}

func (x *Observation) Air() *AirCondition {
	if x.data == nil {
		return &AirCondition{}
	}
	return &AirCondition{data: x.data.Air}
}

func (x *Observation) Wind() []WindCondition {
	if len(x.data.Wind) == 0 {
		return nil
	}
	data := []WindCondition{}
	for _, mem := range x.data.Wind {
		data = append(data, WindCondition{data: &mem})
	}
	return data
}

func (x *Observation) DeicingChemical() *DeicingChemical {
	if x.data == nil {
		return &DeicingChemical{}
	}
	return &DeicingChemical{data: x.data.DeicingChemical}
}

func (x *Observation) Subsurface() *SubsurfaceCondition {
	if x.data == nil {
		return &SubsurfaceCondition{}
	}
	return &SubsurfaceCondition{data: x.data.Subsurface}
}

func (x *Observation) Aggregated5minutes() *Aggregated {
	if x.data == nil {
		return &Aggregated{}
	}
	return &Aggregated{data: x.data.Aggregated5minutes}
}

func (x *Observation) Aggregated10minutes() *Aggregated {
	if x.data == nil {
		return &Aggregated{}
	}
	return &Aggregated{data: x.data.Aggregated10minutes}
}

func (x *Observation) Aggregated30minutes() *Aggregated {
	if x.data == nil {
		return &Aggregated{}
	}
	return &Aggregated{data: x.data.Aggregated30minutes}
}

// SV: Unik publiceringsidentitet för observationen.
// EN: Unique publication identity for the observation.
func (x *Observation) ID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Id
}

type Weather struct {
	data *schema.Weather
}

func (x *Weather) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Weather{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vilken typ av nederbörd som detekterats.
// EN: The type of precipitation detected.
func (x *Weather) Precipitation() *PrecipTypeMeasure {
	if x.data == nil {
		return nil
	}
	return (*PrecipTypeMeasure)(x.data.Precipitation)
}

type SurfaceCondition struct {
	data *schema.SurfaceCondition
}

func (x *SurfaceCondition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.SurfaceCondition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vägytans temperatur. Value [C]
// EN: The temperature of the road surface. Value [C]
func (x *SurfaceCondition) Temperature() *Celsius {
	if x.data == nil {
		return &Celsius{}
	}
	return &Celsius{data: x.data.Temperature}
}

// SV: Förekomst av vatten på vägytan.
// EN: Presence of water on the road surface.
func (x *SurfaceCondition) Water() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Water
}

// SV: Förekomst av is på vägytan.
// EN: Presence of ice on the road surface.
func (x *SurfaceCondition) Ice() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Ice
}

// SV: Förekomst av snö på vägytan.
// EN: Presence of snow on the road surface.
func (x *SurfaceCondition) Snow() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Snow
}

// SV: Value [0-1]
// EN: Value [0-1]
func (x *SurfaceCondition) Grip() *Grip {
	if x.data == nil {
		return &Grip{}
	}
	return &Grip{data: x.data.Grip}
}

// SV: Vattendjup på vägytan. Value [mm]
// EN: Water depth on the road surface. Value [mm]
func (x *SurfaceCondition) WaterDepth() *Millimeters {
	if x.data == nil {
		return &Millimeters{}
	}
	return &Millimeters{data: x.data.WaterDepth}
}

// SV: Isdjup på vägytan. Value [mm]
// EN: Ice depth on the road surface. Value [mm]
func (x *SurfaceCondition) IceDepth() *Millimeters {
	if x.data == nil {
		return &Millimeters{}
	}
	return &Millimeters{data: x.data.IceDepth}
}

// SV: Snödjup på vägytan.
// EN: Snow depth on the road surface.
func (x *SurfaceCondition) SnowDepth() *Snow {
	if x.data == nil {
		return &Snow{}
	}
	return &Snow{data: x.data.SnowDepth}
}

type AirCondition struct {
	data *schema.AirCondition
}

func (x *AirCondition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.AirCondition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Lufttemperatur. Value [C]
// EN: Air temperature. Value [C]
func (x *AirCondition) Temperature() *Celsius {
	if x.data == nil {
		return &Celsius{}
	}
	return &Celsius{data: x.data.Temperature}
}

// SV: Daggpunkt, den temperatur där vatten kondenserar. Value [C]
// EN: Dew point, the temperature at which water condenses. Value [C]
func (x *AirCondition) Dewpoint() *Celsius {
	if x.data == nil {
		return &Celsius{}
	}
	return &Celsius{data: x.data.Dewpoint}
}

// SV: Relativ luftfuktighet. Andel av den fukt som luften kan bära. Vid 100% är luften mättad. Value [%]
// EN: Relative humidity. Proportion of the moisture that the air can carry. At 100%, the air is saturated. Value [%]
func (x *AirCondition) RelativeHumidity() *Percentage {
	if x.data == nil {
		return &Percentage{}
	}
	return &Percentage{data: x.data.RelativeHumidity}
}

// SV: Den sträcka det finns sikt. Value [m] OBS! Ej kvalitetssäkrad.
// EN: The distance there is visibility. Value [m] Please note, quality not verified!
func (x *AirCondition) VisibleDistance() *Meters {
	if x.data == nil {
		return &Meters{}
	}
	return &Meters{data: x.data.VisibleDistance}
}

type WindCondition struct {
	data *schema.WindCondition
}

func (x *WindCondition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.WindCondition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *WindCondition) Height() *WindSensorHeight {
	if x.data == nil {
		return nil
	}
	return (*WindSensorHeight)(x.data.Height)
}

// SV: Mått på vindhastighet vid en viss tidpunkt. Medelvärde över tiominutersperiod t.o.m. tidpunkten. Value [m/s]
// EN: Measure of wind speed at a specific point in time. Average over a ten-minute period up to and including the time period. Value [m/s]
func (x *WindCondition) Speed() *MetersPerSecond {
	if x.data == nil {
		return &MetersPerSecond{}
	}
	return &MetersPerSecond{data: x.data.Speed}
}

// SV: Mått på vindriktning vid en viss tidpunkt. Medelvärde över tiominutersperiod t.o.m. tidpunkten. Value [grader]
// EN: Measure of wind direction at a given point in time. Average over a ten-minute period up to and including the time period. Value [degrees]
func (x *WindCondition) Direction() *Degrees {
	if x.data == nil {
		return &Degrees{}
	}
	return &Degrees{data: x.data.Direction}
}

type DeicingChemical struct {
	data *schema.DeicingChemical
}

func (x *DeicingChemical) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.DeicingChemical{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mängd salt vid mätpunkten. Value [g/kvm]
// EN: Amount of salt at the measuring point. Value [g/sqm]
func (x *DeicingChemical) Amount() *GramPerSquareMeter {
	if x.data == nil {
		return &GramPerSquareMeter{}
	}
	return &GramPerSquareMeter{data: x.data.Amount}
}

type SubsurfaceCondition struct {
	data *schema.SubsurfaceCondition
}

func (x *SubsurfaceCondition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.SubsurfaceCondition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *SubsurfaceCondition) Ground() []GroundCondition {
	if len(x.data.Ground) == 0 {
		return nil
	}
	data := []GroundCondition{}
	for _, mem := range x.data.Ground {
		data = append(data, GroundCondition{data: &mem})
	}
	return data
}

type Celsius struct {
	data *schema.Celsius
}

func (x *Celsius) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Celsius{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *Celsius) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *Celsius) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *Celsius) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Grip struct {
	data *schema.Grip
}

func (x *Grip) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Grip{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *Grip) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *Grip) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *Grip) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Millimeters struct {
	data *schema.Millimeters
}

func (x *Millimeters) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Millimeters{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *Millimeters) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *Millimeters) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *Millimeters) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Snow struct {
	data *schema.Snow
}

func (x *Snow) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Snow{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mängd snö. Value [mm]
// EN: Amount of snow. Value [mm]
func (x *Snow) Solid() *Millimeters {
	if x.data == nil {
		return &Millimeters{}
	}
	return &Millimeters{data: x.data.Solid}
}

// SV: Mängd vatten som snön motsvarar i smält form. Value [mm]
// EN: Amount of water that the snow corresponds to in melted form. Value [mm]
func (x *Snow) WaterEquivalent() *Millimeters {
	if x.data == nil {
		return &Millimeters{}
	}
	return &Millimeters{data: x.data.WaterEquivalent}
}

type Percentage struct {
	data *schema.Percentage
}

func (x *Percentage) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Percentage{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *Percentage) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *Percentage) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *Percentage) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Meters struct {
	data *schema.Meters
}

func (x *Meters) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Meters{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *Meters) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *Meters) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *Meters) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type MetersPerSecond struct {
	data *schema.MetersPerSecond
}

func (x *MetersPerSecond) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.MetersPerSecond{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *MetersPerSecond) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *MetersPerSecond) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *MetersPerSecond) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Degrees struct {
	data *schema.Degrees
}

func (x *Degrees) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Degrees{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *Degrees) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *Degrees) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *Degrees) Value() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type GramPerSquareMeter struct {
	data *schema.GramPerSquareMeter
}

func (x *GramPerSquareMeter) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.GramPerSquareMeter{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *GramPerSquareMeter) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *GramPerSquareMeter) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *GramPerSquareMeter) Value() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type GroundCondition struct {
	data *schema.GroundCondition
}

func (x *GroundCondition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.GroundCondition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Det djup som observationen avser och är negativt för att återspegla att det avser under markytan. Value [cm]
// EN: The depth to which the observation refers and is negative to reflect that it refers to below the surface of the ground. Value [cm]
func (x *GroundCondition) Depth() *IntegerCentimeters {
	if x.data == nil {
		return &IntegerCentimeters{}
	}
	return &IntegerCentimeters{data: x.data.Depth}
}

// SV: Temperatur (grader celsius) vid ett visst djup i marken. Value [C]
// EN: Temperature (degrees celsius) at a certain depth in the ground. Value [C]
func (x *GroundCondition) Temperature() *Celsius {
	if x.data == nil {
		return &Celsius{}
	}
	return &Celsius{data: x.data.Temperature}
}

type Aggregated struct {
	data *schema.Aggregated
}

func (x *Aggregated) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Aggregated{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *Aggregated) Wind() *WindConditionAggregated {
	if x.data == nil {
		return &WindConditionAggregated{}
	}
	return &WindConditionAggregated{data: x.data.Wind}
}

func (x *Aggregated) Precipitation() *PrecipitationConditionAggregated {
	if x.data == nil {
		return &PrecipitationConditionAggregated{}
	}
	return &PrecipitationConditionAggregated{data: x.data.Precipitation}
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
type Origin string

const (
	OriginCalculated Origin = "calculated"
	OriginMeasured   Origin = "measured"
	OriginEstimated  Origin = "estimated"
)

type IntegerCentimeters struct {
	data *schema.IntegerCentimeters
}

func (x *IntegerCentimeters) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.IntegerCentimeters{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Mätvärdets ursprung
// EN: Origin of the metric
func (x *IntegerCentimeters) Origin() *Origin {
	if x.data == nil {
		return nil
	}
	return (*Origin)(x.data.Origin)
}

// SV: Sensorernas beteckning
// EN: Designation of the sensors
func (x *IntegerCentimeters) SensorNames() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SensorNames
}

func (x *IntegerCentimeters) Value() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type WindConditionAggregated struct {
	data *schema.WindConditionAggregated
}

func (x *WindConditionAggregated) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.WindConditionAggregated{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *WindConditionAggregated) Height() *WindSensorHeight {
	if x.data == nil {
		return nil
	}
	return (*WindSensorHeight)(x.data.Height)
}

// SV: Högst uppmätt 3-sekundersmedelvärde under perioden. Value [m/s]
// EN: Highest measured 3-second average over the period. Value [m/s]
func (x *WindConditionAggregated) SpeedMax() *MetersPerSecond {
	if x.data == nil {
		return &MetersPerSecond{}
	}
	return &MetersPerSecond{data: x.data.SpeedMax}
}

// SV: Value [m/s]
// EN: Value [m/s]
func (x *WindConditionAggregated) SpeedAverage() *MetersPerSecond {
	if x.data == nil {
		return &MetersPerSecond{}
	}
	return &MetersPerSecond{data: x.data.SpeedAverage}
}

type PrecipitationConditionAggregated struct {
	data *schema.PrecipitationConditionAggregated
}

func (x *PrecipitationConditionAggregated) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PrecipitationConditionAggregated{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Förekomst av regn.
// EN: Presence of rain.
func (x *PrecipitationConditionAggregated) Rain() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Rain
}

// SV: Förekomst av snö.
// EN: Presence of snow.
func (x *PrecipitationConditionAggregated) Snow() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Snow
}

// SV: Mängd regn under perioden. Value [mm]
// EN: Amount of rain during the period. Value [mm]
func (x *PrecipitationConditionAggregated) RainSum() *Millimeters {
	if x.data == nil {
		return &Millimeters{}
	}
	return &Millimeters{data: x.data.RainSum}
}

// SV: Mängd snö under perioden.
// EN: Amount of snow during the period.
func (x *PrecipitationConditionAggregated) SnowSum() *Snow {
	if x.data == nil {
		return &Snow{}
	}
	return &Snow{data: x.data.SnowSum}
}

// SV: Mängd vatten som nederbörden under perioden motsvarar. Value [mm]
// EN: Amount of water to which the precipitation during the period corresponds. Value [mm]
func (x *PrecipitationConditionAggregated) TotalWaterEquivalent() *Millimeters {
	if x.data == nil {
		return &Millimeters{}
	}
	return &Millimeters{data: x.data.TotalWaterEquivalent}
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "github.com/phille97/trafikinfo/trv/weathermeasurepoint/v2dot1"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError         `xml:"ERROR"`
		Data  []WeatherMeasurepoint `xml:"WeatherMeasurepoint"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
