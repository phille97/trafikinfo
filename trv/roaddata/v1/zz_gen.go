// Package v1 contains the type definitions for RoadData v1.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1

import (
	"encoding/xml"
	"strings"
	"time"

	schema "github.com/phille97/trafikinfo/internal/trv/roaddata/v1"
	"github.com/phille97/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func T() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "RoadData",
		Version:   "1",
		Namespace: "",
	}
}

type RoadData struct {
	data *schema.RoadData
}

func (x *RoadData) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadData{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Län.
// EN: County.
func (x *RoadData) County() *int {
	if x.data == nil {
		return nil
	}
	return x.data.County
}

// SV: Huvudvägnummer.
// EN: Main number.
func (x *RoadData) RoadMainNumber() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadMainNumber
}

// SV: Undervägnummer. Kallas ibland även punktväg. Måste användas ihop med huvudvägnumret.
// EN: Sub number. Must be used combined with the main road number.
func (x *RoadData) RoadSubNumber() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadSubNumber
}

func (x *RoadData) Direction() *Direction {
	if x.data == nil {
		return &Direction{}
	}
	return &Direction{data: x.data.Direction}
}

// SV: Körfältsbeskrivning. Beskrivning av körfältskombinationer, främst för att utskilja vilka vägar som har s.k. 2+1 körfältsuppdelning.
// EN: Lane description. Description of lane combinations, mainly to distinguish which roads have so-called 2+1 lane division.
func (x *RoadData) LaneDescription() *int {
	if x.data == nil {
		return nil
	}
	return x.data.LaneDescription
}

// SV: Start löpande längd. Anges i meter. Starten för aktuell data angivet i antal meter från vägnumrets start inom det länet, i aktuell riktning.
// EN: Start continous length. Indicated in meters. The start of current action information given in the number of meters from the start of the road number within that county, in the current direction.
func (x *RoadData) StartContinuousLength() *int {
	if x.data == nil {
		return nil
	}
	return x.data.StartContinuousLength
}

// SV: Slut löpande längd. Anges i meter. Slutet för aktuell data angivet i antal meter från vägnumrets start inom det länet, i aktuell riktning.
// EN: End continous length. Indicated in meters. The end of the current action information given in the number of meters from the start of the road number within that county, in the current direction.
func (x *RoadData) EndContinuousLength() *int {
	if x.data == nil {
		return nil
	}
	return x.data.EndContinuousLength
}

// SV: Längd.
func (x *RoadData) Length() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Length
}

func (x *RoadData) BearingCapacity() *BearingCapacity {
	if x.data == nil {
		return &BearingCapacity{}
	}
	return &BearingCapacity{data: x.data.BearingCapacity}
}

// SV: Hastighetsgräns. Skyltad hastighet. Vid variabel hastighet visar pmsv3 1000 km/h för att markera att hastigheten inte är entydig.
// EN: Speed limit. Speed limit signs. At variable speed, pmsv3 shows 1000 km/h to indicate that the speed is not unambiguous.
func (x *RoadData) SpeedLimit() *int {
	if x.data == nil {
		return nil
	}
	return x.data.SpeedLimit
}

// SV: Slitlager
// EN: Wear layer
func (x *RoadData) WearLayer() *int {
	if x.data == nil {
		return nil
	}
	return x.data.WearLayer
}

// SV: ÅDT fordon. På mötesseparerad väg anges ÅDT för en riktning i taget. Dvs. den siffra som anges är trafiken i en riktning. På vanlig väg, dvs där trafiken går i båda riktningar, utan mittseparering, gäller ÅDT-siffran båda riktningar tillsammans. Om det finns fler än ett körfält gäller angivna ÅDT-siffran för alla körfält tillsammans. T.ex: Om ÅDT = 20000 fordon och det finns 3 körfält, så kommer ÅDT att anges som 20000 för varje körfält.
// EN: AADT vehicle. On separated roads, AADT is specified for one direction at a time. That is, the figure given is the traffic in one direction. On ordinary roads, i.e. where traffic goes in both directions, without central separation, the AADT figure applies to both directions together. If there is more than one lane, the specified AADT figure applies to all lanes combined. For example: If AADT = 20000 vehicles and there are 3 lanes, then AADT will be set as 20000 for each lane.
func (x *RoadData) AADT() *int {
	if x.data == nil {
		return nil
	}
	return x.data.AADT
}

// SV: ÅDT tung. ÅDT lastbilar avser trafikflöde lastbilar. (Antal lastbilar per årsmedeldygn).
// EN: AADT heavy. AADT trucks refer to the traffic flow of trucks. (Number of trucks per annual average day).
func (x *RoadData) AADTHeavyVehicles() *int {
	if x.data == nil {
		return nil
	}
	return x.data.AADTHeavyVehicles
}

// SV: ÅDT mätår.
// EN: ÅDT Measurement Year
func (x *RoadData) AADTMeasurementYear() *int {
	if x.data == nil {
		return nil
	}
	return x.data.AADTMeasurementYear
}

func (x *RoadData) AADTMeasurementMethod() *AADTMeasurementMethod {
	if x.data == nil {
		return &AADTMeasurementMethod{}
	}
	return &AADTMeasurementMethod{data: x.data.AADTMeasurementMethod}
}

// SV: Vägbredd.
// EN: Road Width
func (x *RoadData) RoadWidth() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.RoadWidth
}

func (x *RoadData) RoadOwner() *RoadOwner {
	if x.data == nil {
		return &RoadOwner{}
	}
	return &RoadOwner{data: x.data.RoadOwner}
}

func (x *RoadData) RoadCategory() *RoadCategory {
	if x.data == nil {
		return &RoadCategory{}
	}
	return &RoadCategory{data: x.data.RoadCategory}
}

func (x *RoadData) RoadType() *RoadType {
	if x.data == nil {
		return &RoadType{}
	}
	return &RoadType{data: x.data.RoadType}
}

func (x *RoadData) Vagunderhallsklass() *Vagunderhallsklass {
	if x.data == nil {
		return &Vagunderhallsklass{}
	}
	return &Vagunderhallsklass{data: x.data.Vagunderhallsklass}
}

// SV: Vägnybyggnadsår 2009. Det årtal som en nybyggnad utförts på vägen, vägsträckan byggdes, och det årtal som ett förstärkningsarbete utförts på en vägsträcka.
// EN: Year of road construction 2009. The year in which a new construction was carried out on the road, the road section was built, and the year in which reinforcement work was carried out on a road section.
func (x *RoadData) RoadConstruction2009() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadConstruction2009
}

// SV: Datum för när vägdata hämtades ut från källsystemet.
// EN: The date when the road data was extracted from the source system.
func (x *RoadData) TimeStamp() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.TimeStamp
}

// EN: Specifies when the object is stored.
// SV: Anger när objektet är sparat.
func (x *RoadData) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

// EN: Specifies if the object is deleted.
// SV: Anger om objektet är raderat.
func (x *RoadData) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

type Direction struct {
	data *schema.Direction
}

func (x *Direction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Direction{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Riktning. Värde.
// EN: Direction. Value.
func (x *Direction) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Riktning. Beskrivning.
// EN: Direction. Description.
func (x *Direction) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type BearingCapacity struct {
	data *schema.BearingCapacity
}

func (x *BearingCapacity) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.BearingCapacity{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Bärighetsklass. Upplåten bärighetsklass på statliga och kommunala vägar. Värde.
// EN: Bearing capacity class. Permitted bearing capacity class on state and municipal roads. Value.
func (x *BearingCapacity) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Bärighetsklass. Upplåten bärighetsklass på statliga och kommunala vägar. Beskrivning.
// EN: Bearing capacity class. Permitted bearing capacity class on state and municipal roads. Description.
func (x *BearingCapacity) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type AADTMeasurementMethod struct {
	data *schema.AADTMeasurementMethod
}

func (x *AADTMeasurementMethod) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.AADTMeasurementMethod{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: ÅDT mätmetod. värde.
// EN: ÅDT measurement method. value.
func (x *AADTMeasurementMethod) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: ÅDT mätmetod. beskrivning.
// EN: ÅDT measurement method. Description.
func (x *AADTMeasurementMethod) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type RoadOwner struct {
	data *schema.RoadOwner
}

func (x *RoadOwner) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadOwner{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Väghållare. Den som är ansvarig för väghållningen.
// EN: Road maintenance.
func (x *RoadOwner) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Väghållare. Den som är ansvarig för väghållningen. Beskrivning.
// EN: Road maintenance, description.
func (x *RoadOwner) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type RoadCategory struct {
	data *schema.RoadCategory
}

func (x *RoadCategory) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadCategory{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vägkategori. Värde.
// EN: Road Category. Value.
func (x *RoadCategory) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Vägkategori. Beskrivning.
// EN: Road maintenance. Description.
func (x *RoadCategory) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type RoadType struct {
	data *schema.RoadType
}

func (x *RoadType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadType{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vägtyp. Värde.
// EN: Road Type. Value.
func (x *RoadType) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Vägtyp. Beskrivning.
// EN: Road Type. Description.
func (x *RoadType) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

type Vagunderhallsklass struct {
	data *schema.Vagunderhallsklass
}

func (x *Vagunderhallsklass) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Vagunderhallsklass{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Vägunderhållsklass. fd Vinter2003/Klassificering map vinterväghållningstandard. Värde.
// EN: Road maintenance class. ex-Winter2003/Classification of winter road maintenance standards. Value.
func (x *Vagunderhallsklass) Code() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Vägunderhållsklass. fd Vinter2003/Klassificering map vinterväghållningstandard. Beskrivning.
// EN: Road maintenance class. ex-Winter2003/Classification of winter road maintenance standards. Description.
func (x *Vagunderhallsklass) Value() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Value
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "github.com/phille97/trafikinfo/trv/roaddata/v1"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError `xml:"ERROR"`
		Data  []RoadData    `xml:"RoadData"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
