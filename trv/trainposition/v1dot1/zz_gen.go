// Package v1dot1 contains the type definitions for TrainPosition v1.1.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1dot1

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/trainposition/v1dot1"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "TrainPosition",
		Version:   "1.1",
		Namespace: "järnväg.trafikinfo",
	}
}

type TrainPosition struct {
	data *schema.TrainPosition
}

func (x *TrainPosition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrainPosition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Tåginformation
// EN: Train information
func (x *TrainPosition) Train() *Train {
	if x.data == nil {
		return new(Train)
	}
	return &Train{data: x.data.Train}
}

// SV: Senast registrerade position för tåget
// EN: Last known position of the train
func (x *TrainPosition) Position() *Position {
	if x.data == nil {
		return new(Position)
	}
	return &Position{data: x.data.Position}
}

// SV: Tiden då positionen uppmättes
// EN: The time when the position was measured
func (x *TrainPosition) TimeStamp() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.TimeStamp
}

// SV: Tågets aktuell status
// EN: The train's current status
func (x *TrainPosition) Status() *Status {
	if x.data == nil {
		return new(Status)
	}
	return &Status{data: x.data.Status}
}

// SV: Tågets bäring i grader
// EN: The train's bearing in degrees
func (x *TrainPosition) Bearing() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Bearing
}

// SV: Tågets hastighet i kilometer per timme
// EN: The train's speed in kilometers per hour
func (x *TrainPosition) Speed() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Speed
}

// SV: Versionsnumret för ett tågs position
// EN: The version number for a train's position
func (x *TrainPosition) VersionNumber() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.VersionNumber
}

// EN: Specifies when the object is stored.
// SV: Anger när objektet är sparat.
func (x *TrainPosition) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

func (x *TrainPosition) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

type Train struct {
	data *schema.Train
}

func (x *Train) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Train{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Operativt tågnummer
// EN: Operational train number
func (x *Train) OperationalTrainNumber() *string {
	if x.data == nil {
		return nil
	}
	return x.data.OperationalTrainNumber
}

// SV: Det operativa tågets utgångsdag
// EN: The operational train's departure day
func (x *Train) OperationalTrainDepartureDate() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.OperationalTrainDepartureDate
}

// SV: Tågets uppdragsnummer
// EN: The train's daily journey plan number
func (x *Train) JourneyPlanNumber() *string {
	if x.data == nil {
		return nil
	}
	return x.data.JourneyPlanNumber
}

// SV: Tåguppdragets utgångsdag
// EN: Daily journey plan departure day
func (x *Train) JourneyPlanDepartureDate() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.JourneyPlanDepartureDate
}

// SV: Tågets annonserade tågnummer (tågnumret som står på biljetten)
// EN: The train's advertised train number
func (x *Train) AdvertisedTrainNumber() *string {
	if x.data == nil {
		return nil
	}
	return x.data.AdvertisedTrainNumber
}

type Position struct {
	data *schema.Position
}

func (x *Position) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Position{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Koordinater uttryckt i formatet sweref99tm
// EN: Coordinates in sweref99tm format
func (x *Position) SWEREF99TM() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SWEREF99TM
}

// SV: Koordinater uttryckt i formatet wgs84
// EN: Coordinates in wgs84 format
func (x *Position) WGS84() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WGS84
}

type Status struct {
	data *schema.Status
}

func (x *Status) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Status{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Flagga som visar om tåget är aktivt
// EN: A flag that shows whether or not the train is active
func (x *Status) Active() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Active
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/trainposition/v1dot1"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError   `xml:"ERROR"`
		Data  []TrainPosition `xml:"TrainPosition"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
