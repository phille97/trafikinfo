// Package v1dot9 contains the type definitions for TrainAnnouncement v1.9.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1dot9

import (
	"encoding/xml"
	"strings"
	"time"

	schema "github.com/phille97/trafikinfo/internal/trv/trainannouncement/v1dot9"
	"github.com/phille97/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func T() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "TrainAnnouncement",
		Version:   "1.9",
		Namespace: "",
	}
}

type ObjectType string

const (
	ObjectTypeTR ObjectType = "TR"
	ObjectTypePA ObjectType = "PA"
	ObjectTypeCR ObjectType = "CR"
	ObjectTypePR ObjectType = "PR"
	ObjectTypeTC ObjectType = "TC"
)

type TrainAnnouncement struct {
	data *schema.TrainAnnouncement
}

func (x *TrainAnnouncement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrainAnnouncement{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Aktivitetens unika id
func (x *TrainAnnouncement) ActivityID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ActivityId
}

// SV: "Ankomst" eller "Avgang"
func (x *TrainAnnouncement) ActivityType() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ActivityType
}

// SV: Anger om ankomsten/avgången annonseras i tidtabell
func (x *TrainAnnouncement) Advertised() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Advertised
}

// SV: Tidtabellstid
func (x *TrainAnnouncement) AdvertisedTimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.AdvertisedTimeAtLocation
}

// SV: Annonserat tågnummer (tågnumret som står på biljetten)
func (x *TrainAnnouncement) AdvertisedTrainIdent() *string {
	if x.data == nil {
		return nil
	}
	return x.data.AdvertisedTrainIdent
}

// SV: Kod för bokningsinformation och bokningsinformation, ex: "Vagn 4 obokad
func (x *TrainAnnouncement) Bookings() []Booking {
	if len(x.data.Booking) == 0 {
		return nil
	}
	data := []Booking{}
	for _, mem := range x.data.Booking {
		data = append(data, Booking{data: &mem})
	}
	return data
}

// SV: Anger om ankomsten/avgången är inställd
func (x *TrainAnnouncement) Canceled() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Canceled
}

// SV: Anger att dataposten raderats
func (x *TrainAnnouncement) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

// SV: Utgångsdatum för det Operativa tågnumret.
func (x *TrainAnnouncement) DepartureDateOTN() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.DepartureDateOTN
}

// SV: Eventuell avvikelse med full orsakskod, ex: ABC023 och beskrivning, ex: "Buss ersätter", "Spårändrat", "Kort tåg", "Ej servering" o.s.v.
func (x *TrainAnnouncement) Deviations() []Deviation {
	if len(x.data.Deviation) == 0 {
		return nil
	}
	data := []Deviation{}
	for _, mem := range x.data.Deviation {
		data = append(data, Deviation{data: &mem})
	}
	return data
}

// SV: Tidpunkt för beräknad ankomst eller avgång
func (x *TrainAnnouncement) EstimatedTimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.EstimatedTimeAtLocation
}

// SV: Anger om en beräknad tid är preliminär. Notera att om den beräknade tiden är preliminär så innebär det att den kan ändras både framåt och bakåt, ett tåg kan alltså t.ex avgå tidigare än beräknad tidpunkt om den också är markerad som preliminär.
func (x *TrainAnnouncement) EstimatedTimeIsPreliminary() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.EstimatedTimeIsPreliminary
}

// SV: Från station för tåget med ordning och i vilken prioritet som ska visas. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. FromLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur från-stationer ska annonseras.
func (x *TrainAnnouncement) FromLocations() []FromLocation {
	if len(x.data.FromLocation) == 0 {
		return nil
	}
	data := []FromLocation{}
	for _, mem := range x.data.FromLocation {
		data = append(data, FromLocation{data: &mem})
	}
	return data
}

// SV: Namnet på trafikinformationsägaren
func (x *TrainAnnouncement) InformationOwner() *string {
	if x.data == nil {
		return nil
	}
	return x.data.InformationOwner
}

// SV: Det operativa tågets ankomst- eller avgångstid enligt tidtabell (kan skilja sig från den annonserade tiden).
func (x *TrainAnnouncement) LocationDateTimeOTN() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.LocationDateTimeOTN
}

// SV: Signatur för stationen
func (x *TrainAnnouncement) LocationSignature() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationSignature
}

// SV: Url till trafikägarens mobila hemsida
func (x *TrainAnnouncement) MobileWebLink() *string {
	if x.data == nil {
		return nil
	}
	return x.data.MobileWebLink
}

// SV: Tidpunkt då dataposten ändrades
func (x *TrainAnnouncement) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

// SV: Anger i vilken ordning tåget nyutrustats. Om ingen nyutrustning skett kommer värdet vara noll
func (x *TrainAnnouncement) NewEquipment() *int {
	if x.data == nil {
		return nil
	}
	return x.data.NewEquipment
}

// SV: Det järnvägsföretag som utför järnvägstrafik, alltså kör tåget, för en trafikorganisatör.
func (x *TrainAnnouncement) Operator() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Operator
}

// SV: Operativt tågnummer (OTN).
func (x *TrainAnnouncement) OperationalTrainNumber() *string {
	if x.data == nil {
		return nil
	}
	return x.data.OperationalTrainNumber
}

// SV: Identifierare i TAF/TAP format.
// EN: Identifiers in TAF/TAP format.
func (x *TrainAnnouncement) OperationalTransportIdentifiers() []CompositIdentifierOperationalType {
	if len(x.data.OperationalTransportIdentifiers) == 0 {
		return nil
	}
	data := []CompositIdentifierOperationalType{}
	for _, mem := range x.data.OperationalTransportIdentifiers {
		data = append(data, CompositIdentifierOperationalType{data: &mem})
	}
	return data
}

// SV: Kod för övrig annonseringsinformation och övrig annonseringsinformation, ex. "Trevlig resa!", "Bakre fordon går låst!", "Ingen påstigning"
func (x *TrainAnnouncement) OtherInformation() []OtherInformation {
	if len(x.data.OtherInformation) == 0 {
		return nil
	}
	data := []OtherInformation{}
	for _, mem := range x.data.OtherInformation {
		data = append(data, OtherInformation{data: &mem})
	}
	return data
}

// SV: Anger en planerad försening och dess giltighet anges med PlannedEstimatedTimeAtLocationIsValid-flaggan
func (x *TrainAnnouncement) PlannedEstimatedTimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.PlannedEstimatedTimeAtLocation
}

// SV: Anger om PlaneradBeraknadTid är giltig. Kommer sättas till false när en operativ beräknad tidrapport, tidrapport eller slopningsrapport skapas
func (x *TrainAnnouncement) PlannedEstimatedTimeAtLocationIsValid() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.PlannedEstimatedTimeAtLocationIsValid
}

// SV: Kod för beskrivning av tåget och beskrivning av tåget, ex. "Tågkompaniet", "SJ InterCity", "TiB/Tågkomp"
func (x *TrainAnnouncement) ProductInformation() []ProductInformation {
	if len(x.data.ProductInformation) == 0 {
		return nil
	}
	data := []ProductInformation{}
	for _, mem := range x.data.ProductInformation {
		data = append(data, ProductInformation{data: &mem})
	}
	return data
}

// SV: Tågets annonserade avgångsdatum
func (x *TrainAnnouncement) ScheduledDepartureDateTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ScheduledDepartureDateTime
}

// SV: Servicekod och lite extra utöver produktinformation, ex "Bistro", "Sov-och liggv"
func (x *TrainAnnouncement) Services() []Service {
	if len(x.data.Service) == 0 {
		return nil
	}
	data := []Service{}
	for _, mem := range x.data.Service {
		data = append(data, Service{data: &mem})
	}
	return data
}

// SV: När tåget har ankommit eller avgått
func (x *TrainAnnouncement) TimeAtLocation() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.TimeAtLocation
}

// SV: När tåget har ankommit eller avgått, med sekunder
func (x *TrainAnnouncement) TimeAtLocationWithSeconds() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.TimeAtLocationWithSeconds
}

// SV: Till station för tåget med ordning och i vilken prioritet som ska visas. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ToLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur till-stationer ska annonseras.
func (x *TrainAnnouncement) ToLocations() []ToLocation {
	if len(x.data.ToLocation) == 0 {
		return nil
	}
	data := []ToLocation{}
	for _, mem := range x.data.ToLocation {
		data = append(data, ToLocation{data: &mem})
	}
	return data
}

// SV: Spår
func (x *TrainAnnouncement) TrackAtLocation() *string {
	if x.data == nil {
		return nil
	}
	return x.data.TrackAtLocation
}

// SV: Kod för tågsammansättning och tågsammansättning, ex: "Vagnsordning 7, 6, 5, 4, 2, 1"
func (x *TrainAnnouncement) TrainCompositions() []TrainComposition {
	if len(x.data.TrainComposition) == 0 {
		return nil
	}
	data := []TrainComposition{}
	for _, mem := range x.data.TrainComposition {
		data = append(data, TrainComposition{data: &mem})
	}
	return data
}

// SV: Ägaren av det aktuella tågläget
func (x *TrainAnnouncement) TrainOwner() *string {
	if x.data == nil {
		return nil
	}
	return x.data.TrainOwner
}

// SV: Trafiktypen, ex. "Buss", "Pendeltåg", "Taxi", "Tåg".
func (x *TrainAnnouncement) TypesOfTraffic() []TypeOfTraffic {
	if len(x.data.TypeOfTraffic) == 0 {
		return nil
	}
	data := []TypeOfTraffic{}
	for _, mem := range x.data.TypeOfTraffic {
		data = append(data, TypeOfTraffic{data: &mem})
	}
	return data
}

func (x *TrainAnnouncement) ViaFromLocations() []ViaFromLocation {
	if len(x.data.ViaFromLocation) == 0 {
		return nil
	}
	data := []ViaFromLocation{}
	for _, mem := range x.data.ViaFromLocation {
		data = append(data, ViaFromLocation{data: &mem})
	}
	return data
}

func (x *TrainAnnouncement) ViaToLocations() []ViaToLocation {
	if len(x.data.ViaToLocation) == 0 {
		return nil
	}
	data := []ViaToLocation{}
	for _, mem := range x.data.ViaToLocation {
		data = append(data, ViaToLocation{data: &mem})
	}
	return data
}

// SV: Url till trafikägarens hemsida
func (x *TrainAnnouncement) WebLink() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WebLink
}

// SV: Namn på trafikinfoägaren att använda i länkar
func (x *TrainAnnouncement) WebLinkName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WebLinkName
}

type Booking struct {
	data *schema.Booking
}

func (x *Booking) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Booking{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för bokningsinformation
func (x *Booking) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som ger bokningsinformation, ex: "Vagn 4 obokad", "Platsbiljett krävs"
func (x *Booking) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type Deviation struct {
	data *schema.Deviation
}

func (x *Deviation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Deviation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för avvikelse
func (x *Deviation) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver avvikelse, ex: "Buss ersätter", "Spårändrat", "Kort tåg", "Ej servering", "Oväder"
func (x *Deviation) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type FromLocation struct {
	data *schema.FromLocation
}

func (x *FromLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.FromLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på frånstation. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. FromLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur från-stationer ska annonseras.
func (x *FromLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *FromLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *FromLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

type CompositIdentifierOperationalType struct {
	data *schema.CompositIdentifierOperationalType
}

func (x *CompositIdentifierOperationalType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.CompositIdentifierOperationalType{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Ger möjlighet att beskriva olika objekt inför en ansökan, TR = Train, PA = Path, CR = Case Reference, PR = Path Request
// EN: Provides a possibility for differentiantion between the objects: Train, Path, Case Reference and Path Request
func (x *CompositIdentifierOperationalType) ObjectType() *ObjectType {
	if x.data == nil {
		return nil
	}
	return (*ObjectType)(x.data.ObjectType)
}

// SV: Företagskod UIC för den som utfärdat identiteten
// EN: Identifies the RU, IM or other company involved in the Rail Transport Chain
func (x *CompositIdentifierOperationalType) Company() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Company
}

// SV: Huvuddelen av identifieraren.
// EN: It is the main part of identifier and is determent by the company that creates it.
func (x *CompositIdentifierOperationalType) Core() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Core
}

// SV: Varianten visar relationen mellan två id'n som refererar samma affärsobjekt
// EN: The variant shows a relationship between two identifiers referring to the same business case
func (x *CompositIdentifierOperationalType) Variant() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Variant
}

// SV: Refererar till tågplan där behovet ska exekveras
// EN: Refers to the timetable period in which the business will be carried out
func (x *CompositIdentifierOperationalType) TimetableYear() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.TimetableYear
}

// SV: Starten då behovet exekveras
// EN: The start of the date/time in effect
func (x *CompositIdentifierOperationalType) StartDate() *string {
	if x.data == nil {
		return nil
	}
	return x.data.StartDate
}

type OtherInformation struct {
	data *schema.OtherInformation
}

func (x *OtherInformation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.OtherInformation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för övrig annonseringsinformation
func (x *OtherInformation) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som ger övrig annonseringinformation, ex. "Trevlig resa!", "Bakre vagnen låst!", "Ingen påstigning"
func (x *OtherInformation) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type ProductInformation struct {
	data *schema.ProductInformation
}

func (x *ProductInformation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ProductInformation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för produkten
func (x *ProductInformation) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver produkten, ex. "Västtågen", "SJ Snabbtåg", "Pågatågen"
func (x *ProductInformation) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type Service struct {
	data *schema.Service
}

func (x *Service) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Service{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för service
func (x *Service) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver den service som finns, ex "Bistro", "Sov-och liggvagnar", "Kiosk"
func (x *Service) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type ToLocation struct {
	data *schema.ToLocation
}

func (x *ToLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ToLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Tillstation för tåget. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ToLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur till-stationer ska annonseras.
func (x *ToLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *ToLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *ToLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

type TrainComposition struct {
	data *schema.TrainComposition
}

func (x *TrainComposition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrainComposition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för tågsammansättning
func (x *TrainComposition) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Text som beskriver tågsammansättning, ex: "Vagnsordning 7, 6, 5, 4, 2, 1"
func (x *TrainComposition) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type TypeOfTraffic struct {
	data *schema.TypeOfTraffic
}

func (x *TypeOfTraffic) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TypeOfTraffic{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Kod för trafiktyp
func (x *TypeOfTraffic) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Trafiktypen, ex. "Buss", "Pendeltåg", "Taxi", "Tåg".
func (x *TypeOfTraffic) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type ViaFromLocation struct {
	data *schema.ViaFromLocation
}

func (x *ViaFromLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ViaFromLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på via frånstation. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ViaFromLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur från-stationer ska annonseras.
func (x *ViaFromLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *ViaFromLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *ViaFromLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

type ViaToLocation struct {
	data *schema.ViaToLocation
}

func (x *ViaToLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ViaToLocation{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på vi. Notera att det avser vad som ska annonseras för resenärerna, det vill säga vad som ska visas på skyltar o.dyl. ViaToLocation kan med andra ord ha olika innehåll för samma tåg vid olika stationer och olika innehåll vad ankomster respektive avgångar. Fältet anger hur till-stationer ska annonseras.
func (x *ViaToLocation) LocationName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationName
}

// SV: Prioritet för vilka stationer som ska visas.
func (x *ViaToLocation) Priority() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Priority
}

// SV: Vilken ordning stationer ska visas.
func (x *ViaToLocation) Order() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Order
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "github.com/phille97/trafikinfo/trv/trainannouncement/v1dot9"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError       `xml:"ERROR"`
		Data  []TrainAnnouncement `xml:"TrainAnnouncement"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
