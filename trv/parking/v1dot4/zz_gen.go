// Package v1dot4 contains the type definitions for Parking v1.4.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1dot4

import (
	"encoding/xml"
	"strings"
	"time"

	schema "github.com/phille97/trafikinfo/internal/trv/parking/v1dot4"
	"github.com/phille97/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func T() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "Parking",
		Version:   "1.4",
		Namespace: "",
	}
}

type Parking struct {
	data *schema.Parking
}

func (x *Parking) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Parking{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: <div class="toggleTitle">Länsnummer</div> <div class="toggle arrowR"> </div> <div class="toggleContent"> <table class="table table-condensed"> <tr> <td>1</td> <td>Stockholms län</td> </tr> <tr> <td>2</td> <td> DEPRECATED<br /> Användes tidigare för Stockholms län </td> </tr> <tr> <td>3</td> <td>Uppsala län</td> </tr> <tr> <td>4</td> <td>Södermanlands län</td> </tr> <tr> <td>5</td> <td>Östergötlands län</td> </tr> <tr> <td>6</td> <td>Jönköpings län</td> </tr> <tr> <td>7</td> <td>Kronobergs län</td> </tr> <tr> <td>8</td> <td>Kalmar län</td> </tr> <tr> <td>9</td> <td>Gotlands län</td> </tr> <tr> <td>10</td> <td>Blekinge län</td> </tr> <tr> <td>12</td> <td>Skåne län</td> </tr> <tr> <td>13</td> <td>Hallands län</td> </tr> <tr> <td>14</td> <td>Västra Götalands län</td> </tr> <tr> <td>17</td> <td>Värmlands län</td> </tr> <tr> <td>18</td> <td>Örebro län</td> </tr> <tr> <td>19</td> <td>Västmanlands län</td> </tr> <tr> <td>20</td> <td>Dalarnas län</td> </tr> <tr> <td>21</td> <td>Gävleborgs län</td> </tr> <tr> <td>22</td> <td>Västernorrlands län</td> </tr> <tr> <td>23</td> <td>Jämtlands län</td> </tr> <tr> <td>24</td> <td>Västerbottens län</td> </tr> <tr> <td>25</td> <td>Norrbottens län</td> </tr> </table> </div>
func (x *Parking) Counties() []int {
	if x.data == nil {
		return nil
	}
	return x.data.CountyNo
}

// EN: Specifies if the object is deleted.
// SV: Anger om objektet är raderat.
func (x *Parking) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

// SV: Beskrivning av parkeringen
func (x *Parking) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

// SV: Avstånd till närmaste stad
func (x *Parking) DistanceToNearestCity() *string {
	if x.data == nil {
		return nil
	}
	return x.data.DistanceToNearestCity
}

func (x *Parking) Equipment() []Equipment {
	if len(x.data.Equipment) == 0 {
		return nil
	}
	data := []Equipment{}
	for _, mem := range x.data.Equipment {
		data = append(data, Equipment{data: &mem})
	}
	return data
}

func (x *Parking) Facilities() []Facility {
	if len(x.data.Facility) == 0 {
		return nil
	}
	data := []Facility{}
	for _, mem := range x.data.Facility {
		data = append(data, Facility{data: &mem})
	}
	return data
}

func (x *Parking) Geometry() *Geometry {
	if x.data == nil {
		return &Geometry{}
	}
	return &Geometry{data: x.data.Geometry}
}

// SV: Ikonid
func (x *Parking) IconID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.IconId
}

// SV: Parkeringens id
func (x *Parking) ID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Id
}

// SV: Lägesbeskrivning
func (x *Parking) LocationDescription() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LocationDescription
}

// SV: Parkeringens namn
func (x *Parking) Name() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Name
}

// SV: Anger om rastplatsen är öppen eller stängd (open, closed)
func (x *Parking) OpenStatus() *string {
	if x.data == nil {
		return nil
	}
	return x.data.OpenStatus
}

// SV: Anger om det finns några driftstörningar på rastplatsen (limitedOperation) eller om allt fungerar (inOperation)
func (x *Parking) OperationStatus() *string {
	if x.data == nil {
		return nil
	}
	return x.data.OperationStatus
}

func (x *Parking) Operator() *Operator {
	if x.data == nil {
		return &Operator{}
	}
	return &Operator{data: x.data.Operator}
}

func (x *Parking) ParkingAccess() []ParkingAccess {
	if len(x.data.ParkingAccess) == 0 {
		return nil
	}
	data := []ParkingAccess{}
	for _, mem := range x.data.ParkingAccess {
		data = append(data, ParkingAccess{data: &mem})
	}
	return data
}

func (x *Parking) Photos() []Photo {
	if len(x.data.Photo) == 0 {
		return nil
	}
	data := []Photo{}
	for _, mem := range x.data.Photo {
		data = append(data, Photo{data: &mem})
	}
	return data
}

func (x *Parking) TariffsAndPayment() *TariffsAndPayment {
	if x.data == nil {
		return &TariffsAndPayment{}
	}
	return &TariffsAndPayment{data: x.data.TariffsAndPayment}
}

// SV: Anger användningsområde
func (x *Parking) UsageSenarios() []string {
	if x.data == nil {
		return nil
	}
	return x.data.UsageSenario
}

func (x *Parking) VehicleCharacteristics() []VehicleCharacteristics {
	if len(x.data.VehicleCharacteristics) == 0 {
		return nil
	}
	data := []VehicleCharacteristics{}
	for _, mem := range x.data.VehicleCharacteristics {
		data = append(data, VehicleCharacteristics{data: &mem})
	}
	return data
}

// EN: Specifies when the object is stored.
// SV: Anger när objektet är sparat.
func (x *Parking) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

func (x *Parking) CheckoutID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Checkoutid
}

func (x *Parking) Checkouts() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.Checkouts
}

func (x *Parking) LeasedUntil() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.Leaseduntil
}

func (x *Parking) Acknowledged() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.Acknowledged
}

func (x *Parking) StatusCode() *uint8 {
	if x.data == nil {
		return nil
	}
	return x.data.Statuscode
}

func (x *Parking) ItemsAcknowledged() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.Itemsacknowledged
}

func (x *Parking) ItemsLeft() *int64 {
	if x.data == nil {
		return nil
	}
	return x.data.Itemsleft
}

type Equipment struct {
	data *schema.Equipment
}

func (x *Equipment) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Equipment{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: <div class="toggleTitle"> Typ av utrustning </div> <div class="toggle arrowR"> </div> <div class="toggleContent"> <table class="table table-condensed"> <tr> <td>toilet</td> </tr> <tr> <td>shower</td> </tr> <tr> <td>informationPoint</td> </tr> <tr> <td>informatonStele</td> </tr> <tr> <td>internetTerminal</td> </tr> <tr> <td>internetWireless</td> </tr> <tr> <td>payDesk</td> </tr> <tr> <td>paymentMachine</td> </tr> <tr> <td>cashMachine</td> </tr> <tr> <td>vendingMachine</td> </tr> <tr> <td>faxMachineOrService</td> </tr> <tr> <td>copyMachineOrService</td> </tr> <tr> <td>safeDeposit</td> </tr> <tr> <td>luggageLocker</td> </tr> <tr> <td>publicPhone</td> </tr> <tr> <td>publicCoinPhone</td> </tr> <tr> <td>publicCardPhone</td> </tr> <tr> <td>elevator</td> </tr> <tr> <td>picnicFacilities</td> </tr> <tr> <td>dumpingStation</td> </tr> <tr> <td>freshWater</td> </tr> <tr> <td>wasteDisposal</td> </tr> <tr> <td>refuseBin</td> </tr> <tr> <td>iceFreeScaffold</td> </tr> <tr> <td>playground</td> </tr> <tr> <td>electricChargingStation</td> </tr> <tr> <td>bikeParking</td> </tr> <tr> <td>tollTerminal</td> </tr> <tr> <td>defibrillator</td> </tr> <tr> <td>firstAidEquipment</td> </tr> <tr> <td>fireHose</td> </tr> <tr> <td>fireExtingiusher</td> </tr> <tr> <td>fireHydrant</td> </tr> <tr> <td>none</td> </tr> <tr> <td>unknown</td> </tr> <tr> <td>other</td> </tr> </table> </div>
func (x *Equipment) Type() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Type
}

// SV: <div class="toggleTitle"> Utrustningens tillgänglighet </div> <div class="toggle arrowR"> </div> <div class="toggleContent"> <table class="table table-condensed"> <tr> <td>barrierFreeAccessible</td> </tr> <tr> <td>handicappedAccessible</td> </tr> <tr> <td>wheelChairAccessible</td> </tr> <tr> <td>handicappedEasements</td> </tr> <tr> <td>orientationSystemForBlindPeople</td> </tr> <tr> <td>handicappedMarked</td> </tr> <tr> <td>none</td> </tr> <tr> <td>unknown</td> </tr> <tr> <td>other</td> </tr> </table> </div>
func (x *Equipment) Accessibility() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Accessibility
}

type Facility struct {
	data *schema.Facility
}

func (x *Facility) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Facility{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: <div class="toggleTitle"> Serviceanläggningar vid parkeringen </div> <div class="toggle arrowR"> </div> <div class="toggleContent"> <table class="table table-condensed"> <tr> <td>hotel</td> </tr> <tr> <td>motel</td> </tr> <tr> <td>overnightAccommodation</td> </tr> <tr> <td>shop</td> </tr> <tr> <td>kiosk</td> </tr> <tr> <td>foodShopping</td> </tr> <tr> <td>cafe</td> </tr> <tr> <td>restaurant</td> </tr> <tr> <td>restaurantSelfService</td> </tr> <tr> <td>motorwayRestaurant</td> </tr> <tr> <td>motorwayRestaurantSmall</td> </tr> <tr> <td>sparePartsShopping</td> </tr> <tr> <td>petrolStation</td> </tr> <tr> <td>vehicleMaintenance</td> </tr> <tr> <td>tyreRepair</td> </tr> <tr> <td>truckRepair</td> </tr> <tr> <td>truckWash</td> </tr> <tr> <td>carWash</td> </tr> <tr> <td>pharmacy</td> </tr> <tr> <td>medicalFacility</td> </tr> <tr> <td>police</td> </tr> <tr> <td>touristInformation</td> </tr> <tr> <td>bikeSharing</td> </tr> <tr> <td>docstop</td> </tr> <tr> <td>laundry</td> </tr> <tr> <td>leisureActivities</td> </tr> <tr> <td>unknown</td> </tr> <tr> <td>other</td> </tr> </table> </div>
func (x *Facility) Type() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Type
}

// SV: <div class="toggleTitle"> Serviceanläggningens tillgänglighet </div> <div class="toggle arrowR"> </div> <div class="toggleContent"> <table class="table table-condensed"> <tr> <td>barrierFreeAccessible</td> </tr> <tr> <td>handicappedAccessible</td> </tr> <tr> <td>wheelChairAccessible</td> </tr> <tr> <td>handicappedEasements</td> </tr> <tr> <td>orientationSystemForBlindPeople</td> </tr> <tr> <td>handicappedMarked</td> </tr> <tr> <td>none</td> </tr> <tr> <td>unknown</td> </tr> <tr> <td>other</td> </tr> </table> </div>
func (x *Facility) Accessibility() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Accessibility
}

type Geometry struct {
	data *schema.Geometry
}

func (x *Geometry) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Geometry{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Parkeringens position som en geometrisk punkt i koordinatsystemet SWEREF99TM
func (x *Geometry) SWEREF99TM() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SWEREF99TM
}

// SV: Parkeringens position som en geometrisk punkt i koordinatsystemet WGS84
func (x *Geometry) WGS84() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WGS84
}

type Operator struct {
	data *schema.Operator
}

func (x *Operator) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Operator{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på operatörens kontakt
func (x *Operator) Contact() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Contact
}

// SV: Operatörens kontaktmail
func (x *Operator) ContactEmail() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ContactEmail
}

// SV: Operatörens kontakttelefon
func (x *Operator) ContactTelephoneNumber() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ContactTelephoneNumber
}

// SV: Operatörens namn
func (x *Operator) Name() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Name
}

type ParkingAccess struct {
	data *schema.ParkingAccess
}

func (x *ParkingAccess) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.ParkingAccess{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Parkeringens anslutning som en geometrisk punkt i koordinatsystemet SWEREF99TM
func (x *ParkingAccess) SWEREF99TM() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SWEREF99TM
}

// SV: Parkeringens anslutning som en geometrisk punkt i koordinatsystemet WGS84
func (x *ParkingAccess) WGS84() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WGS84
}

type Photo struct {
	data *schema.Photo
}

func (x *Photo) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Photo{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Namn på foto
func (x *Photo) Title() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Title
}

// SV: Url till foto
func (x *Photo) URL() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Url
}

type TariffsAndPayment struct {
	data *schema.TariffsAndPayment
}

func (x *TariffsAndPayment) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TariffsAndPayment{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Anger om parkeringen är gratis att använda
func (x *TariffsAndPayment) FreeOfCharge() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.FreeOfCharge
}

// SV: Anger parkeringens avgift
func (x *TariffsAndPayment) Tariff() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Tariff
}

type VehicleCharacteristics struct {
	data *schema.VehicleCharacteristics
}

func (x *VehicleCharacteristics) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.VehicleCharacteristics{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Fordonstyp parkeringen är avsedd för
func (x *VehicleCharacteristics) VehicleType() *string {
	if x.data == nil {
		return nil
	}
	return x.data.VehicleType
}

// SV: Antal platser för fordonstypen inkl släp
func (x *VehicleCharacteristics) NumberOfSpaces() *uint8 {
	if x.data == nil {
		return nil
	}
	return x.data.NumberOfSpaces
}

// SV: Typ av last parkeringen är avsedd för, exempelvis fryst gods (refrigeratedGoods)
func (x *VehicleCharacteristics) LoadType() *string {
	if x.data == nil {
		return nil
	}
	return x.data.LoadType
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "github.com/phille97/trafikinfo/trv/parking/v1dot4"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError `xml:"ERROR"`
		Data  []Parking     `xml:"Parking"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
