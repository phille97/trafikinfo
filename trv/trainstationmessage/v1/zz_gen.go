// Package v1 contains the type definitions for TrainStationMessage v1.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1

import (
	"encoding/xml"
	"strings"
	"time"

	schema "code.dny.dev/trafikinfo/internal/trv/trainstationmessage/v1"
	"code.dny.dev/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func ObjectType() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "TrainStationMessage",
		Version:   "1",
		Namespace: "",
	}
}

type TrainStationMessage struct {
	data *schema.TrainStationMessage
}

func (x *TrainStationMessage) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrainStationMessage{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Unikt id för varje meddelande
// EN: Unique identifier
func (x *TrainStationMessage) ID() *string {
	return x.data.Id
}

// SV: Anger vilket presentationsmedia meddelandet gäller.<br /> 'Monitor'<br /> 'Plattformsskylt'<br /> 'Utrop'
// EN: Type of media.<br /> 'Monitor' - Monitor<br /> 'Plattformsskylt'- Platform sign<br /> 'Utrop' - Announcement
func (x *TrainStationMessage) MediaType() *string {
	return x.data.MediaType
}

// SV: Stationens platssignatur
// EN: Location code
func (x *TrainStationMessage) LocationCode() *string {
	return x.data.LocationCode
}

// SV: Trafikhändelsenummer från Basun
// EN: Id in the BASUN application
func (x *TrainStationMessage) EventID() *string {
	return x.data.EventId
}

// SV: När meddelandet ska börja visas
// EN: When the message should start to be displayed
func (x *TrainStationMessage) StartDateTime() *time.Time {
	return x.data.StartDateTime
}

// SV: När meddelandet ska sluta visas
// EN: When the message should not be displayed anymore
func (x *TrainStationMessage) EndDateTime() *time.Time {
	return x.data.EndDateTime
}

// SV: Anger att ett meddelande bara skall gälla mellan tidpunkterna i Starttid och Sluttid, för varje dag i intervallet Starttid och Sluttid
// EN: For the dates specified in Start and EndDateTime, specifies if the message should be displayed around the clock or just between the time set in Start and EndDateTime each day
func (x *TrainStationMessage) SplitActivationTime() *bool {
	return x.data.SplitActivationTime
}

// SV: Annonseringstexten
// EN: Informational text
func (x *TrainStationMessage) FreeText() *string {
	return x.data.FreeText
}

// SV: Meddelandets viktighetsgrad
// EN: How important the message are (in relative to other messages)
func (x *TrainStationMessage) Status() *string {
	return x.data.Status
}

// SV: Version på detta meddelande
// EN: Versioning number for this external message
func (x *TrainStationMessage) VersionNumber() *int {
	return x.data.VersionNumber
}

// SV: En sträng som beskriver om ett meddelande ska vara aktivt (Y) eller inte (N) för varje dag från Starttid till Sluttid.
// EN: A string with an 'Y' or 'N' for each day between the start and the end date. 'Y' if the message is to be active that day and 'N' otherwise.
func (x *TrainStationMessage) ActiveDays() *string {
	return x.data.ActiveDays
}

func (x *TrainStationMessage) MonitorAttributes() *MonitorAttributes {
	return &MonitorAttributes{data: x.data.MonitorAttributes}
}

func (x *TrainStationMessage) PlatformSignAttributes() *PlatformSignAttributes {
	return &PlatformSignAttributes{data: x.data.PlatformSignAttributes}
}

func (x *TrainStationMessage) PublicAnnouncementAttributes() *PublicAnnouncementAttributes {
	return &PublicAnnouncementAttributes{data: x.data.PublicAnnouncementAttributes}
}

// SV: Anger att dataposten raderats
// EN: Specifies if the element has been deleted
func (x *TrainStationMessage) Deleted() *bool {
	return x.data.Deleted
}

// SV: Tidpunkt då dataposten ändrades
// EN: Time when the element wast last modified
func (x *TrainStationMessage) ModifiedTime() *time.Time {
	return x.data.ModifiedTime
}

type MonitorAttributes struct {
	data *schema.MonitorAttributes
}

func (x *MonitorAttributes) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.MonitorAttributes{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Anger om meddelandet skall visas på pendelmonitor.
// EN: Specifies if the monitor is a commuter monitor or regular
func (x *MonitorAttributes) CommuterMonitor() *bool {
	return x.data.CommuterMonitor
}

// SV: Anger om monitormeddelandet även skall visas på stortavla.
// EN: Specifies if the message is to be shown on a big screen monitor
func (x *MonitorAttributes) BigScreenMonitorActivated() *bool {
	return x.data.BigScreenMonitorActivated
}

type PlatformSignAttributes struct {
	data *schema.PlatformSignAttributes
}

func (x *PlatformSignAttributes) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PlatformSignAttributes{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Anger om meddelandet skall visas på pendelplattformsskylt eller en vanlig plattformsskylt.
// EN: Specifies if the message is to be shown on a commuter platform sign or regular platform sign
func (x *PlatformSignAttributes) CommuterPlatformSign() *bool {
	return x.data.CommuterPlatformSign
}

// SV: Vilka spår som meddelandet gäller
// EN: The tracks that are affected by the message
func (x *PlatformSignAttributes) TrackList() *TrackList {
	return &TrackList{data: x.data.TrackList}
}

type PublicAnnouncementAttributes struct {
	data *schema.PublicAnnouncementAttributes
}

func (x *PublicAnnouncementAttributes) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PublicAnnouncementAttributes{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Utropstext på engelska.
// EN: Announcement text in English.
func (x *PublicAnnouncementAttributes) EnglishText() *string {
	return x.data.EnglishText
}

// SV: Om Utropsystem ska ropa på engelska.
// EN: Specifies if the message is announced in English.
func (x *PublicAnnouncementAttributes) EnglishPublicAnnouncementActivated() *bool {
	return x.data.EnglishPublicAnnouncementActivated
}

// SV: En planering för vilka dagar och tidpunkter ett meddelande skall ropas.
// EN: Plans for when the message is to be announced
func (x *PublicAnnouncementAttributes) PublicAnnouncementPlanList() *PublicAnnouncementPlanList {
	return &PublicAnnouncementPlanList{data: x.data.PublicAnnouncementPlanList}
}

func (x *PublicAnnouncementAttributes) PublicAnnouncementZoneList() *PublicAnnouncementZoneList {
	return &PublicAnnouncementZoneList{data: x.data.PublicAnnouncementZoneList}
}

type TrackList struct {
	data *schema.TrackList
}

func (x *TrackList) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.TrackList{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *TrackList) Tracks() []string {
	return x.data.Track
}

type PublicAnnouncementPlanList struct {
	data *schema.PublicAnnouncementPlanList
}

func (x *PublicAnnouncementPlanList) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PublicAnnouncementPlanList{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

func (x *PublicAnnouncementPlanList) PublicAnnouncementPlans() []PublicAnnouncementPlan {
	data := []PublicAnnouncementPlan{}
	for _, mem := range x.data.PublicAnnouncementPlan {
		data = append(data, PublicAnnouncementPlan{data: &mem})
	}
	return data
}

type PublicAnnouncementZoneList struct {
	data *schema.PublicAnnouncementZoneList
}

func (x *PublicAnnouncementZoneList) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PublicAnnouncementZoneList{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Anger en zon där meddelandet skall utropas
// EN: Indicates a zone for where the message is to be announced
func (x *PublicAnnouncementZoneList) PublicAnnouncementZones() []string {
	return x.data.PublicAnnouncementZone
}

type PublicAnnouncementPlan struct {
	data *schema.PublicAnnouncementPlan
}

func (x *PublicAnnouncementPlan) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PublicAnnouncementPlan{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Planeringen är giltig efter denna tidpunkt och är första aktiva dagen i planeringen.
// EN: The start and first valid date of the plan.
func (x *PublicAnnouncementPlan) ValidFrom() *time.Time {
	return x.data.ValidFrom
}

// SV: Planeringen är giltig fram till denna tidpunkt och är sista aktiva dagen i planeringen.
// EN: The end and last valid date of the plan.
func (x *PublicAnnouncementPlan) ValidTo() *time.Time {
	return x.data.ValidTo
}

// SV: En sträng som beskriver om en planering är aktiv (Y) eller inte (N) för varje dag från Starttid till Sluttid.
// EN: A string with an 'Y' or 'N' for each day between the start and the end date. 'Y' if the message is to be announced that day and 'N' otherwise.
func (x *PublicAnnouncementPlan) ActiveDays() *string {
	return x.data.ActiveDays
}

func (x *PublicAnnouncementPlan) PublicAnnouncementOccasionList() *PublicAnnouncementOccasionList {
	return &PublicAnnouncementOccasionList{data: x.data.PublicAnnouncementOccasionList}
}

type PublicAnnouncementOccasionList struct {
	data *schema.PublicAnnouncementOccasionList
}

func (x *PublicAnnouncementOccasionList) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.PublicAnnouncementOccasionList{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Anger vilken minut på dygnet ett utrop skall utföras
// EN: Indicates which minute in the day the announcement is to be made
func (x *PublicAnnouncementOccasionList) PublicAnnouncementOccasions() []int {
	return x.data.PublicAnnouncementOccasion
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "code.dny.dev/trafikinfo/trv/trainstationmessage/v1"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError         `xml:"ERROR"`
		Data  []TrainStationMessage `xml:"TrainStationMessage"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
