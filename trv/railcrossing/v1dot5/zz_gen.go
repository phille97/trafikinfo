// Package v1dot5 contains the type definitions for RailCrossing v1.5.
//
// All types have accessor methods to access fields which can be chained on nils.
// This makes it possible to easily drill down into deeply nested data.
package v1dot5

import (
	"encoding/xml"
	"strings"
	"time"

	schema "github.com/phille97/trafikinfo/internal/trv/railcrossing/v1dot5"
	"github.com/phille97/trafikinfo/trv"
)

// THIS FILE IS AUTOMATICALLY GENERATED FROM THE XSD. DO NOT EDIT.

func T() trv.ObjectType {
	return trv.ObjectType{
		Kind:      "RailCrossing",
		Version:   "1.5",
		Namespace: "",
	}
}

type RailCrossing struct {
	data *schema.RailCrossing
}

func (x *RailCrossing) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RailCrossing{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Tidpunkt då plankorsningens data senast ändrades
func (x *RailCrossing) DataLastUpdated() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.DataLastUpdated
}

// SV: Information om plankorsningen gäller från och med detta datum.
func (x *RailCrossing) FromDate() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.FromDate
}

// SV: Information om plankorsningen gäller till och med detta datum.
func (x *RailCrossing) ToDate() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ToDate
}

// SV: Unikt id för plankorsning.
func (x *RailCrossing) ObjectID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.ObjectId
}

// SV: Plankorsningens femsiffriga idnummer
func (x *RailCrossing) LevelCrossingID() *int {
	if x.data == nil {
		return nil
	}
	return x.data.LevelCrossingId
}

// SV: Id för rutt, används för att referera till andra datamängder med samma id
func (x *RailCrossing) RailwayRouteID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.RailwayRouteId
}

// SV: Id för vägen
func (x *RailCrossing) RouteID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.RouteId
}

// SV: Id för rutt, används för att referera till andra datamängder med samma id
func (x *RailCrossing) RoadRouteID() *string {
	if x.data == nil {
		return nil
	}
	return x.data.RoadRouteId
}

// SV: Antal spår i plankorsningen
func (x *RailCrossing) NumberOfTracks() *int {
	if x.data == nil {
		return nil
	}
	return x.data.NumberOfTracks
}

// SV: Driftläge, T.ex. "I drift", "Stängd", "Okänd" eller "Blankt" (okänd)
func (x *RailCrossing) OperatingMode() *string {
	if x.data == nil {
		return nil
	}
	return x.data.OperatingMode
}

// SV: Tågflöde, vid värde 0 eller inget angivet värde så saknas uppgifter om tågflöde.
func (x *RailCrossing) TrainFlow() *int {
	if x.data == nil {
		return nil
	}
	return x.data.TrainFlow
}

// SV: Portalhöjd höger
func (x *RailCrossing) PortalHeightLeft() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.PortalHeightLeft
}

// SV: Portalhöjd höger
func (x *RailCrossing) PortalHeightRight() *float64 {
	if x.data == nil {
		return nil
	}
	return x.data.PortalHeightRight
}

// SV: Vägnamn.
func (x *RailCrossing) RoadName() *string {
	if x.data == nil {
		return nil
	}
	return x.data.RoadName
}

// SV: Alternativt vägnamn
func (x *RailCrossing) RoadNameAlternative() *string {
	if x.data == nil {
		return nil
	}
	return x.data.RoadNameAlternative
}

// SV: Kommunalt gatunamn
func (x *RailCrossing) RoadNameOfficial() *string {
	if x.data == nil {
		return nil
	}
	return x.data.RoadNameOfficial
}

// SV: Vägprofil tvär kurva. Kurva nära plankorsningen där ett vägfordon med släp riskerar att fastna. <br xmlns="http://trafikverket.se/RailCrossing.xsd" /> Värdemängd: 0: uppgift saknas, 1: Ja, 2: Nej
func (x *RailCrossing) RoadProfileCrossCurve() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadProfileCrossCurve
}

// SV: Vägprofil farligt vägkrön. Vertikal vägprofil där ett vägfordon med låg markfrigång riskerar att fastna.<br xmlns="http://trafikverket.se/RailCrossing.xsd" /> Värdemängd: 0: Uppgift saknas, 1: Ja, 2: Nej
func (x *RailCrossing) RoadProfileDangerousCrest() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadProfileDangerousCrest
}

// SV: Vägprofil vägkrön. Vertikal vägprofil där ett vägfordon med låg markfrigång riskerar att fastna. <br xmlns="http://trafikverket.se/RailCrossing.xsd" /> Värdemängd: 0: Uppgift saknas, 1: Ja, 2: Nej
func (x *RailCrossing) RoadProfileCrest() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadProfileCrest
}

// SV: Vägprofil brant lutning. Vägbanan inom 25 meter från plankorsningen lutar mer än +/- 35 promille. <br xmlns="http://trafikverket.se/RailCrossing.xsd" /> Värdemängd: 0: uppgift saknas, 1: Ja, 2: Nej
func (x *RailCrossing) RoadProfileSteepSlope() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadProfileSteepSlope
}

// SV: Vägskydd.
func (x *RailCrossing) RoadProtection() *int {
	if x.data == nil {
		return nil
	}
	return x.data.RoadProtection
}

func (x *RailCrossing) RoadProtectionAdditions() []RoadProtectionAddition {
	if len(x.data.RoadProtectionAddition) == 0 {
		return nil
	}
	data := []RoadProtectionAddition{}
	for _, mem := range x.data.RoadProtectionAddition {
		data = append(data, RoadProtectionAddition{data: &mem})
	}
	return data
}

func (x *RailCrossing) RoadProtectionBases() []RoadProtectionBase {
	if len(x.data.RoadProtectionBase) == 0 {
		return nil
	}
	data := []RoadProtectionBase{}
	for _, mem := range x.data.RoadProtectionBase {
		data = append(data, RoadProtectionBase{data: &mem})
	}
	return data
}

// SV: Bandel
func (x *RailCrossing) TrackPortion() *string {
	if x.data == nil {
		return nil
	}
	return x.data.TrackPortion
}

// SV: Plankorsningens meter-tal enligt banans längdmätning
func (x *RailCrossing) Meter() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Meter
}

// SV: Plankorsningens kilometer-tal enligt banans längdmätning
func (x *RailCrossing) Kilometer() *int {
	if x.data == nil {
		return nil
	}
	return x.data.Kilometer
}

func (x *RailCrossing) Geometry() *Geometry {
	if x.data == nil {
		return &Geometry{}
	}
	return &Geometry{data: x.data.Geometry}
}

// EN: Specifies when the object is stored.
// SV: Anger när objektet är sparat.
func (x *RailCrossing) ModifiedTime() *time.Time {
	if x.data == nil {
		return nil
	}
	return x.data.ModifiedTime
}

// EN: Specifies if the object is deleted.
// SV: Anger om objektet är raderat.
func (x *RailCrossing) Deleted() *bool {
	if x.data == nil {
		return nil
	}
	return x.data.Deleted
}

type RoadProtectionAddition struct {
	data *schema.RoadProtectionAddition
}

func (x *RoadProtectionAddition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadProtectionAddition{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Skyddsalternativ, tillägg <br xmlns="http://trafikverket.se/RailCrossing.xsd" /><div class="toggleTitle" xmlns="http://trafikverket.se/RailCrossing.xsd">Värdemängd</div><div class="toggle arrowR" xmlns="http://trafikverket.se/RailCrossing.xsd" /><div class="toggleContent" xmlns="http://trafikverket.se/RailCrossing.xsd"> 1: Förenklad bevakning alternativ 1 – Vakt bevakar <br /> 2: Förenklad bevakning alternativ 2 – Stopp framför <br /> 3: Förenklad bevakning alternativ 3 – Sth 10 <br /> 4: Förenklad bevakning alternativ 4 – Vakt går före <br /> E: Enkel ljussignal <br /> F: Förlängd förringningstid <br /> Gf: Gångfålla <br /> H: Hinderdetektor <br /> P: Plattformsanläggning med gul signalbild ”STOP” och/eller vita bommar <br /> S: Stoppmärke <br /> V: Ägovägsbom <br /> b: Signalering mot banan som halvbomsprincipen </div>
func (x *RoadProtectionAddition) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Skyddsalternativ, tillägg - Beskrivning av kod
func (x *RoadProtectionAddition) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type RoadProtectionBase struct {
	data *schema.RoadProtectionBase
}

func (x *RoadProtectionBase) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.RoadProtectionBase{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Skyddsalternativ, grund <br xmlns="http://trafikverket.se/RailCrossing.xsd" /><div class="toggleTitle" xmlns="http://trafikverket.se/RailCrossing.xsd">Värdemängd</div><div class="toggle arrowR" xmlns="http://trafikverket.se/RailCrossing.xsd" /><div class="toggleContent" xmlns="http://trafikverket.se/RailCrossing.xsd"> A: Helbommar <br /> B: Halvbommar <br /> C: Ljussignaler <br /> CD: Ljus- och ljudsignaler <br /> D: Ljudsignaler <br /> K: Kryssmärke <br /> O: Oskyddad <br /> -: Saknas </div>
func (x *RoadProtectionBase) Code() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Code
}

// SV: Skyddsalternativ, grund - Beskrivning av kod
func (x *RoadProtectionBase) Description() *string {
	if x.data == nil {
		return nil
	}
	return x.data.Description
}

type Geometry struct {
	data *schema.Geometry
}

func (x *Geometry) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	res := &schema.Geometry{}
	if err := d.DecodeElement(res, &start); err != nil {
		return err
	}
	x.data = res
	return nil
}

// SV: Geometrisk punkt i koordinatsystem SWEREF99TM
func (x *Geometry) SWEREF99TM() *string {
	if x.data == nil {
		return nil
	}
	return x.data.SWEREF99TM
}

// SV: Geometrisk punkt i koordinatsystem WGS84
func (x *Geometry) WGS84() *string {
	if x.data == nil {
		return nil
	}
	return x.data.WGS84
}

// Response can be used to decode the response from the API.
//
// For example:
//
//	package main
//
//	import (
//		 "encoding/xml"
//		 api "github.com/phille97/trafikinfo/trv/railcrossing/v1dot5"
//	)
//
//	func main() {
//		var res api.Response
//		err := xml.Unmarshal(data, &res)
//	}
type Response struct {
	XMLName xml.Name `xml:"RESPONSE"`
	Results []struct {
		Info struct {
			LastModified trv.LastModified `xml:"LASTMODIFIED"`
			LastChangeID string           `xml:"LASTCHANGEID"`
			EvalResult   []any            `xml:"EVALRESULT"`
			SSEURL       string           `xml:"SSEURL"`
		} `xml:"INFO"`
		Error *trv.APIError  `xml:"ERROR"`
		Data  []RailCrossing `xml:"RailCrossing"`
	} `xml:"RESULT"`
}

// HasErrors returns whether any of the results
// includes an error.
func (r Response) HasErrors() bool {
	if len(r.Results) == 0 {
		return false
	}

	res := false
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = true
			break
		}
	}
	return res
}

// Errors returns a slice of [trv.Error], if any error was
// included in the response.
func (r Response) ErrorMsg() string {
	if !r.HasErrors() {
		return ""
	}

	res := []string{}
	for _, rr := range r.Results {
		if rr.Error != nil {
			res = append(res, rr.Error.Error())
		}
	}
	return strings.Join(res, ", ")
}
